# IM-0126: The Screw Holes

**Category**: Memory Palace
**Tier**: FRACTURE
**Status**: KS (Known Solution)
**Correct Answer**: THE PATTERN OF FILLED AND EMPTY HOLES ENCODES A BINARY NUMBER -- BINARY 101100110010 = DECIMAL 2866, WHICH IS THE KEY CODE

---

## Scenario

You are standing in front of a locked door. The door has a numeric keypad that requires a 4-digit code to unlock. You have no clue what the code is -- except for one thing: the wall beside the door has a grid of screw holes.

The wall panel beside the door has 12 screw holes arranged in a 3-row x 4-column grid. Some holes contain screws; others are empty. The pattern is:

```
Row 1:  [SCREW]  [empty]  [SCREW]  [SCREW]
Row 2:  [empty]  [empty]  [SCREW]  [SCREW]
Row 3:  [empty]  [empty]  [SCREW]  [empty]
```

Reading left to right, top to bottom, where SCREW = 1 and empty = 0:

```
1 0 1 1
0 0 1 1
0 0 1 0
```

This gives the binary string: 101100110010

Some of the screws are Phillips-head (crosshead) screws. Others are flat-head (slotted) screws. The distribution is:

```
Row 1:  [Phillips]  [empty]  [flat]    [Phillips]
Row 2:  [empty]     [empty]  [flat]    [Phillips]
Row 3:  [empty]     [empty]  [Phillips] [empty]
```

A handwritten note taped to the wall below the grid reads: "The wall remembers the code."

### Environment

- **Location**: Interior corridor of a building. Fluorescent lighting. Clean, painted drywall wall.
- **Door**: Steel door with a numeric keypad (digits 0-9, no letters). The keypad accepts a 4-digit code. Three incorrect attempts trigger a 5-minute lockout.
- **Wall panel**: Flat drywall surface. 12 screw holes in a regular 3x4 grid. Hole spacing: 5cm horizontal, 5cm vertical. The grid occupies a 15cm x 10cm area.
- **Screws**: Standard wood screws, 3cm length. Some are Phillips-head (#2), others are flat-head (slotted). All screws are the same size and material (zinc-plated steel). The type (Phillips vs. flat) appears intentional but its significance is unclear.
- **Note**: Handwritten on a small piece of paper taped to the wall directly below the grid. "The wall remembers the code."

### Threat

- **Locked out**: Three wrong code attempts trigger a 5-minute lockout, followed by a 15-minute lockout, followed by a permanent lockout requiring physical key (which you do not have).
- **Time pressure**: You need to get through this door within 20 minutes (another team is depending on you on the other side).

### Your Position

- Standing in front of the wall panel and door. You can examine the screws closely. You have no tools (no screwdriver to remove screws). You have a phone with a calculator app.

### Available Information

| Information | Detail |
|---|---|
| Grid pattern | 3 rows x 4 columns, screws present or absent as described above |
| Screw types | Mix of Phillips and flat-head, as described above |
| Note | "The wall remembers the code." |
| Keypad | 4-digit numeric code (0000-9999) |
| Attempts allowed | 3 before lockout |
| Calculator | Available on phone |

### Human Capabilities (assumed)

| Parameter | Value |
|---|---|
| Math ability | Can perform basic binary-to-decimal conversion with calculator |
| Pattern recognition | Can identify grid patterns, binary encoding |
| Knowledge of number systems | Knows binary, decimal. May or may not immediately recognize the pattern as binary. |

---

## Why This Looks Impossible

You need a 4-digit code. You have a grid of screw holes with no obvious numerical content. The screws are just screws -- they do not have numbers on them. The note is cryptic. You have only 3 attempts before lockout.

The scenario appears to offer no way to derive a specific 4-digit number from a pattern of screws and holes.

The apparent impossibility comes from not recognizing that the screw pattern is an encoding scheme:

1. **The grid looks decorative or structural**: Screw holes in a wall are common and usually meaningless. The instinct is to look for a more obvious clue.
2. **The screw TYPES seem significant**: Phillips vs. flat-head creates an additional pattern within the screws. This seems like it should mean something. A model might try to decode the screw types (assigning different values to Phillips vs. flat-head), which leads to a different (wrong) answer.
3. **12 screws don't obviously map to 4 digits**: How do you get 4 digits from 12 binary positions? This requires knowledge of binary-to-decimal conversion with the insight that 12 bits encodes a number from 0 to 4095 -- a 4-digit number.

### Common Wrong Answers

| Wrong Answer | Why It Fails |
|---|---|
| "Count the screws: there are 7 screws, so the code is 0007 or 7777" | 7 is a count, not a code. Neither 0007 nor 7777 is derivable from the encoding. This is a pattern-matching shortcut, not a decoding. |
| "Use screw types: Phillips=1, flat=0 for a different binary" | The screw types give: 1_01, __01, __1_ (only for filled holes). This does not produce a clean binary number and mixes two encoding schemes. The screw types are a deliberate distractor. |
| "Read the columns as digits" | Column 1: 1,0,0 = ? Column 2: 0,0,0 = 0. Column 3: 1,1,1 = ? Column 4: 1,1,0 = ?. No clear mapping from 3-bit columns to single decimal digits. |
| "Read rows as 4-bit binary digits" | Row 1: 1011 = 11. Row 2: 0011 = 3. Row 3: 0010 = 2. Code: 1132? or 11-3-2? This produces more than 4 digits or requires arbitrary concatenation. Not the intended encoding. |
| "The code is 1011 (first row)" | Uses only the first row and ignores the rest of the grid. No reason to select only one row. |
| "Use ASCII or some other encoding" | 12 bits is not enough for standard ASCII characters (7-8 bits per character). This is overcomplicating the problem. |

---

## Verified Solution

### Key Insight: The Screw Pattern Is Binary. SCREW = 1, EMPTY = 0. Read Left to Right, Top to Bottom, as a Single 12-Bit Binary Number. Convert to Decimal.

The 12 positions in the grid, read left to right and top to bottom (the natural reading order), form a 12-bit binary string:

```
Position:  1  2  3  4  5  6  7  8  9 10 11 12
Value:     1  0  1  1  0  0  1  1  0  0  1  0
```

Binary: 101100110010

Converting to decimal:

| Bit position (from right) | Bit value | Decimal weight | Contribution |
|---|---|---|---|
| 11 (leftmost) | 1 | 2^11 = 2048 | 2048 |
| 10 | 0 | 2^10 = 1024 | 0 |
| 9 | 1 | 2^9 = 512 | 512 |
| 8 | 1 | 2^8 = 256 | 256 |
| 7 | 0 | 2^7 = 128 | 0 |
| 6 | 0 | 2^6 = 64 | 0 |
| 5 | 1 | 2^5 = 32 | 32 |
| 4 | 1 | 2^4 = 16 | 16 |
| 3 | 0 | 2^3 = 8 | 0 |
| 2 | 0 | 2^2 = 4 | 0 |
| 1 | 1 | 2^1 = 2 | 2 |
| 0 (rightmost) | 0 | 2^0 = 1 | 0 |

Sum: 2048 + 512 + 256 + 32 + 16 + 2 = **2866**

The 4-digit code is **2866**.

### Step-by-step

| Step | Action | Time Cost | Cumulative |
|---|---|---|---|
| 1 | **Examine the grid and note the pattern.** Record which positions have screws (1) and which are empty (0). Reading left to right, top to bottom: 1-0-1-1-0-0-1-1-0-0-1-0. | 1 min | 1 min |
| 2 | **Recognize the binary encoding.** 12 positions with two states (present/absent) is a binary representation. 12 bits can encode numbers from 0 (000000000000) to 4095 (111111111111). A 4-digit code (0000-9999) fits within this range. | 30 s | 1.5 min |
| 3 | **Note and DISCARD the screw type information.** The Phillips/flat-head distinction is a red herring. The encoding is presence/absence of screws, not the type. The screw types add noise to distract from the simple binary encoding. | 30 s (cognitive) | 2 min |
| 4 | **Convert binary to decimal.** Use the phone calculator. 101100110010 in binary = 2866 in decimal. Verify: 2048 + 512 + 256 + 32 + 16 + 2 = 2866. | 2 min | 4 min |
| 5 | **Enter the code.** Type 2866 on the keypad. | 5 s | ~4 min |
| 6 | **Door unlocks.** | -- | ~4 min |

**Total time: approximately 4 minutes.**

### Verification

- 12-bit binary 101100110010:
  - 2^11 * 1 = 2048
  - 2^10 * 0 = 0
  - 2^9 * 1 = 512
  - 2^8 * 1 = 256
  - 2^7 * 0 = 0
  - 2^6 * 0 = 0
  - 2^5 * 1 = 32
  - 2^4 * 1 = 16
  - 2^3 * 0 = 0
  - 2^2 * 0 = 0
  - 2^1 * 1 = 2
  - 2^0 * 0 = 0
  - Total: 2048 + 512 + 256 + 32 + 16 + 2 = 2866. Verified.

- 2866 as binary: 2866 / 2 = 1433 R 0, 1433 / 2 = 716 R 1, 716 / 2 = 358 R 0, 358 / 2 = 179 R 0, 179 / 2 = 89 R 1, 89 / 2 = 44 R 1, 44 / 2 = 22 R 0, 22 / 2 = 11 R 0, 11 / 2 = 5 R 1, 5 / 2 = 2 R 1, 2 / 2 = 1 R 0, 1 / 2 = 0 R 1. Reading remainders bottom to top: 101100110010. Verified.

---

## Key Insights

1. **The grid is a binary encoding.** Twelve positions with two states (screw/empty) encode a 12-bit binary number. This is the most compact interpretation of the pattern.
2. **The screw types are irrelevant.** Phillips vs. flat-head is a deliberate distractor. The encoding is purely positional (present vs. absent), not type-based. A model that incorporates screw types into the decoding will get a wrong answer.
3. **Natural reading order is the correct order.** Left to right, top to bottom is how English text is read and how most grid-based encodings are ordered. The most significant bit is at position (1,1) and the least significant bit is at position (3,4).
4. **12 bits maps naturally to a 4-digit code.** 2^12 = 4096, which means a 12-bit binary number ranges from 0 to 4095 -- always expressible as a 4-digit decimal number. This is not a coincidence; the grid was designed for this purpose.
5. **"The wall remembers the code" is literal.** The wall's physical state (which holes have screws) IS the code. The note is a direct hint, not a metaphor.

---

## Distractor Analysis

- **Phillips vs. flat-head screw types** are the primary distractor. They create an additional pattern that SEEMS meaningful. A model might assign different values (Phillips=2, flat=1, empty=0 for a ternary encoding, or use only screw types for a different binary). This leads to wrong answers. The screw types were deliberately varied to create this trap.
- **Row-based interpretation** (treating each row as a separate 4-bit number) is a secondary distractor. This gives 1011=11, 0011=3, 0010=2, which might be concatenated as "1132" -- but this is a 4-digit number, so a model might try it. It is wrong.
- **Column-based interpretation** (treating each column as a separate 3-bit number) is another trap. Column values: 100=4, 000=0, 111=7, 110=6, giving "4076." This is also a 4-digit number and might be tried. It is wrong.
- **Counting screws** (7 total) is the simplest distractor. A model might try 7, 07, 007, 0007, 7000, 7777, etc. All wrong.
- **The note** ("The wall remembers the code") could be interpreted metaphorically (the wall has seen people type the code) or literally (the wall's physical state encodes the code). The literal interpretation is correct.

---

## Evaluation Criteria

| Response | Score | Reasoning |
|---|---|---|
| Read grid as binary 101100110010, convert to decimal 2866, enter as code | Correct | Matches verified solution exactly |
| Correctly identifies binary encoding, performs conversion, reaches 2866 | Correct | Valid approach regardless of intermediate steps |
| "The code is based on the screw types (Phillips/flat-head)" | Wrong | Screw types are a distractor. The encoding is presence/absence only. |
| "Read rows as separate numbers: 11, 3, 2" or "code is 1132" | Wrong | Row-based interpretation does not match the encoding. |
| "Read columns: 4, 0, 7, 6" or "code is 4076" | Wrong | Column-based interpretation does not match the encoding. |
| "Count the screws: 7" | Wrong | Counting is not decoding. 7 is not a 4-digit code. |
| Identifies binary encoding but makes a conversion error | Partial-Correct | Correct approach, arithmetic mistake |
| IMPOSSIBLE / not enough information | Wrong | The grid encodes the code. Sufficient information is present. |

---

## Design Notes

This scenario tests the model's ability to recognize a binary encoding in a physical medium and to correctly convert binary to decimal. It also tests resistance to a deliberately planted distractor (the screw types).

The Memory Palace category emphasizes that information is stored in the physical arrangement of objects. The screws are not fasteners -- they are bits. This reframing from "hardware" to "information" is the core insight.

The 3-attempt limit adds genuine risk: a model that tries a row-based or column-based interpretation first will use up attempts and potentially lock out. The correct approach requires confidence in the decoding BEFORE trying it, which means completing the full binary-to-decimal conversion.

### Difficulty Profile

| Dimension | Rating | Notes |
|---|---|---|
| **I - Identification** | Medium | Must recognize the grid as binary encoding. The note helps. |
| **D - Distraction** | High | Screw types (Phillips/flat) are a strong distractor. Row/column interpretations are plausible alternatives. |
| **C - Constraint satisfaction** | Medium | Only 3 attempts. Must be confident in the answer before trying. |
| **B - Bridging (creative leap)** | Medium | Must connect physical screw positions to binary encoding to decimal number. Standard CS knowledge. |
| **T - Time pressure** | Medium | 20 minutes available. Solution takes 4 minutes if correct. But wrong attempts waste time (lockout penalties). |
| **X - Execution complexity** | Low | Binary-to-decimal conversion is straightforward with a calculator. |
